# 쿠버네티스 이해와 아키텍처 구성요소

## 1. 쿠버네티스 이해하기

쿠버네티스는 컨테이너 관리 도구로 실제로 `컨테이너 오케스트레이션`을 위한 솔루션입니다.

`오케스트레이션`이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 의미합니다.

즉, 다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어 주는 것이 `오케스트레이션`입니다.

컨테이너 오케스트레이션이 아래와 같은 역할들을 수행합니다.

- 클러트러링
- 상태관리
- 스케줄링
- 배포 버전관리
- 서비스 디스커버리
- 볼륨

쿠버네티스 이외에도 많은 오케스트레이션 솔루션이 있었지만 요즘은 쿠버네티스가 사실상의`(de factor, 데 팍토)` 표준 입니다.

## 2. 쿠버네티스 클러스터 구성요소

`kubernetes-cluster-config` 디렉토리에 Vagrant로 `프로비저닝`을 위한 메인 파일(Vagrantfile)과 쿠버네티스 클러스터를 구성하기 설정 파일들이 있습니다. 

쿠버네티스 클러스터에 명령을 내리는 역할을 하는 마스터 노드 1대와 파드들이 할당되는 워커 노드 3대로 구성하였습니다.

```sh
vagrant up # Vagrantfile이 있는 경로에서 실행

vagrant ssh m-k8s # 쿠버네티스 마스터 노드 접속

kubectl get nodes # 쿠버네티스 클러스터 구성 노드 확인
```

아래 이미지를 통해서 VirtualBox에서 총 4대의 쿠버네티스 클러스터가 정상적으로 구성된 것을 확인할 수 있었습니다.


![스크린샷 2023-04-15 오후 11 26 22](https://user-images.githubusercontent.com/22395934/232230477-52e0c0d1-5a9c-4ecb-afb2-533cc0044431.png)


```sh
kubectl get pods --all-namespaces # default 외에 모든 네임스페이스를 표시
```

![스크린샷 2023-04-15 오후 11 31 57](https://user-images.githubusercontent.com/22395934/232230709-ac5fbc9d-ab40-43b5-bf3b-34bf0db9598b.png)

> 쿠버네티스 구성 요소는 동시에 여러 개가 존재하는 경우 중복된 이름을 피하기 위해서 해시코드가 삽입됩니다. 해시 코드는 무작위 문자열로 생성됩니다. 이름을 직접 지정이 가능하지만 언제라도 문제가 발견되면 다시 생성되는 특성을 가지는 파드로 이루어져 있어서 자동으로 이름을 지정하는 것이 관리하기 쉽습니다.

### 2.1 쿠버네티스 구성 요소 간 통신 구조

![쿠버네티스 구성요소 통신 아키텍처](https://user-images.githubusercontent.com/22395934/232266034-d730c5c1-d604-4b88-ac6a-c351702b07cd.png)


위의 도식도는 실제 책의 나온 아키텍처를 다시 그려봤습니다.

마스터 노드와 워커 노드의 각 요소를 살펴봤습니다.

마스터 노드

- kubectl: 쿠버네티스 클러스터에 명령을 내리는 역할을 합니다. 다른 구성요소들과 다르게 바로 실행되는 명령 형태인 바이너리로 배포되기 때문에 마스터 노드에 꼭 있을 필요는 없습니다. 하지만 통상적으로 API 서버와 주로 통신하므로 마스터 노드에 구성하였습니다.

- API 서버: 쿠버네티스 클러스터의 중심 역할을 하는 통로입니다. 주로 상태 값을 저장하는 `etcd`와 통신하지만, 그 밖의 요소들 또한 API 서버를 중심에 두고 통신하므로 API 서버의 역할이 매우 중요합니다. 회사로 비유하면 모든 직원과 상황을 관리하고 목표를 설정하는 관리자에 해당합니다.

- etcd: 구성 요소들의 상태 값이 모두 저장되는 곳입니다. 회사의 관리자가 모든 보고 내용을 기록하는 노트로 생각하면 됩니다. etcd를 제외하고는 다른 구성 요소는 상태 값을 저장하지 않습니다. 만약 쿠버네티스 클러스터에 장애가 발생한다면 `etcd`의 정보만 백업이 되어 있어도 쿠버네티스 클러스터는 복구가 가능합니다.

> etcd(엣시디)는 리눅스의 구성 정보를 주로 가지고 있는 etc 디렉토리와 distributed의 합성어입니다. 따라서 etcd는 구성 정보를 퍼뜨려 저장하겠다는 의미입니다.

- 컨트롤러 매니저: 컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리합니다. 대표적으로 워커 노드 컨트롤러, 레플리카셋 컨트롤러, 엔드 포인트 컨트롤러가 있습니다. 
이와 같이 다양한 상태 값을 관리하는 주체들이 이 컨트롤러 매니저에 소속돼 각자의 역할을 수행합니다.

- 스케줄러: 노드의  상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당합니다. 스케줄러라는 이름에 걸맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리하는 역할을 담당합니다.

워커 노드

- kubelet: 파드의 구성내용을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링 합니다.

- 컨테이너 런타임(CRI, Container Runtime Interface): 파드를 이루는 컨테이너의 실행을 담당합니다. 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스 입니다.

- 파드: 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위입니다. 즉, 웹 서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있습니다. 핀트는 파드는 언제라도 죽을 수 있는 존재라는 점입니다. 가상 머신은 언제라도 죽을 수 있다고 가정하고 설계되지 않았지만, 파드는 언제라도 죽을 수 있다고 가정하고 설계되었기 때문에 쿠버네티스는 여러 대안을 디자인 했습니다.

선택 가능한 구성 요소

- 네트워크 플러그인: 쿠버네티스 클러스터의 통신을 위해서 네트워크 플러그인을 선택하고 구성해야 합니다. 네트워크 플러그인은 일반적으로 CNI로 구성하는데, 여기서는 `캘리코(Calico)`를 사용했습니다.

- CoreDNS: 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS 서버입니다. 쿠버네티스 클러스터에서 도메인 이름을 이용해 통신하는데 사용합니다. 실무에서는 IP보다 도메인 네임을 편리하게 관리해 주는 CoreDNS를 사용하는 것이 일반적입니다. 

사용자가 배포된 파드에 접속할 때

- kube-proxy: 쿠버네티스 클러스터는 파드가 위치한 노드에 kube-proxy를 통해 파드가 통신할 수 있는 네트워크를 설정합니다. 이때 실제 통신은 br_netfilter와 iptables로 관리합니다. 

- 파드: 이미 배포된 파드에 접속하고 필요한 내용을 전달받습니다. 이때 대부분 사용자는 파드가 어느 워커 노드에 위치하는지 신경쓰지 않아도 됩니다.

쿠버네티스는 아래 이미지처럼 기본적으로 컨테이너 생성을 요청하면 바로 컨테이너를 띄우지 않고 상태체크를 하여 현재 상태와 원하는 상태를 비교하여 차이점을 발견하면 조치를 취하는 방식입니다.

## 2.2 쿠버네티스의 상태 유지 방법

쿠버네티스는 작업을 순서대로 진행하는 워크플로 구조가 아니라 선언적인 시스템 구조를 가지고 있습니다. 즉, 각 요소가 `추구하는 상태`를 선언하면 `현재 상태`와 맞는 지 점검하고  그것에 맞추려고 노력하는 구조로 돼있습니다.

![쿠버네티스 상태체크](https://user-images.githubusercontent.com/22395934/124599364-8e643e80-dea0-11eb-9d0e-53e7b7b6ad81.png)

예를 들어서 외부에서 컨테이너 생성을 요청하면 현재 상태에서 컨테이너가 띄어있는지 체크를 한 후에 올라온 컨테이너가 없으면 컨테이너를 생성합니다.


> 참고문헌: 컨테이너 인프라 환경 구축을 위한 쿠버네티스

