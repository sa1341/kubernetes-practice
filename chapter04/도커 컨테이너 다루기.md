# 도커 컨테이너 다루기 

도커는 이전에 개발용으로 많이 사용하고 있어서 개념을 알고 있어서 간단하게 리마인트 차원에서 다시 정리해봤습니다.

컨테이너 이미지는 앞에서 쿠버네티스 클러스터 구축을 위해 사용한 베어그랜트 이미지와 유사합니다.

컨테이터 이미지도 그대로는 사용할 수 없고 도커와 같은 `CRI(Container Runtime Interface)`로 불러들어야 컨테이너가 실제로 작동합니다. 

이는 실행 파일과 실행된 파일 관계로 볼 수 있습니다. 따라서 컨테이너를 삭제할 때는 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야만 디스크의 용량을 온전히 확보할 수 있습니다.

## 1. 도커 이미지 알아보기

이미지는 레지스트리라고 하는 저장소에 모여 있습니다. 도커 허브가 가장 유명한 대표적인 레지스트리 입니다. 또한 AWS에서 제공하는 `ECR(Elastic Container Registry)`도 있습니다.

아래와 같은 명령어로 도커 이미지를 검색할 수 있습니다.

```bash
docker search <검색어>

docker search nginx
```

![image](https://user-images.githubusercontent.com/22395934/233820402-91d46caf-e99c-45c8-a482-a3af1e73b871.png)

위 이미지에서 각 열의 의미는 다음과 같습니다.

- INDEX: 이미지가 저장된 레지스트리의 이름
- NAME: 검색된 이미지의 이름입니다. 공식 이미지를 제외한 나머지는 `레지스트리 주소/저장소 소유자/이미지 이름` 형태입니다.
- DESCRIPTION: 이미지에 대한 설명입니다.
- STARS: 해당 이미지를 내려받은 사용자에게 받은 평가 횟수입니다. 숫자가 클수록 신뢰성이 높은 이미지일 수 있습니다.
- OFFICAL: [OK] 표시는 해당 이미지에 포함된 어플리케이션, 미들웨어 등을 개발한 업체에서 공식적으로 제공한 이미지 입니다.
- AUTOMATED: [OK] 표시는 도커 허브에서 자체적으로 제공하는 이미지 빌드 자동화 기능을 활용해 생성한 이미지를 뜻합니다.

docker search로 찾은 이미지는 docker pull로 내려받을 수 있습니다.

![image](https://user-images.githubusercontent.com/22395934/233820533-3589983a-f274-4a9d-aa3a-0127a4d32980.png)

이미지를 내려받을 때 사용하는 태그, 레이어, 이미지의 고유 식별 값 등을 볼 수 있습니다.

- 태그(tag): Using default tag와 함께 뒤에 따라오는 태그 이름을 통해 이미지를 내려받을때 사용한 태그를 알 수 있습니다. 아무런 조건을 주지 않고 이미지 이름만으로 pull을 수행하면 
기본으로 `latest` 태그가 적용됩니다. 단어 그대로 가장 최신 이미지를 의미합니다.

- 레이어(layer): 26c5c85e47da, 4f3256bdf66b, 2019c71d5655, 8c767bdbc9ae, 78e14bb05fd3, 75576236abf5는 pull을 수행해 내려받은 레이어 입니다. 하나의 이미지는 여러 개의 레이어로 이루어져 있어서 레이어마다 `pull complete` 메시지가 발생합니다.

- 다이제스트(digest): 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경을 식별할 수 있습니다. 식별자는 해시(hash) 함수로 생성되며 이미지가 동일한지 검증하는데 사용합니다. 이름이나 태그는 이미지를 생성할 때 임의로 지정하므로 이름이나 태그가 같다고 해서 같은 이미지라고 할 수 없습니다. 그러나 다이제스트는 고유한 값이므로 다이제스트가 같은 이미지는 태그가 다르더라도 같은 이미지 입니다.
- 상태(status): 이미지를 내려받은 레지스트리, 이미지, 태그 등의 상태 정보를 확인할 수 있습니다. 형식은 `레지스트리 이름/이미지 이름:태그`입니다 

### 1.1 이미지 태그

`태그`는 이름이 동일한 이미지에 추가하는 식별자입니다. 이름이 동일해도 도커 이미지의 버전이나 플랫폼(CPU 종류나 기본 베이스를 이루는 운영 체제 등이)이 다를 수 있기 때문에 이를 구분하는 데 사용합니다. 

### 1.2 이미지 레이어 구조

앞에서 컨에이너 이미지는 실행 파일이라고 했습니다. 사실 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 `ZIP`같은 압축 파일에 더 가깝습니다.

![도커 이미지 레이어](https://user-images.githubusercontent.com/22395934/233821756-f0cb68ab-d21b-4ab3-9283-6a1434c20783.png)

위 그림을 보면 내부에 동일한 파일이 포함된 압축 파일과 이미지를 보여주고 있습니다. 압축 파일은 내용이 같은 파일 두 개가 각 압축 파일에서 공간을 독립적으로 점유합니다.

그에 반해 이미지는 내용이 같은 레이어1, 레이어2를 공유하기 때문에 전체 공간에서 봤을때 상대적으로 용량을 적게 차지합니다.


실제로 nginx:stable 이미지를 다운받은 후 동일한 레이어는 다운받지 않고 스킵하는지 확인해봤습니다.

```bash
docker images nginx # 내려받은 이미지 조

docker pull nginx:stable
```

![image](https://user-images.githubusercontent.com/22395934/233821863-dae148e4-e208-4335-85ee-dbc97882c50b.png)

`26c5c85e47da` 실제 해당 레이어가 이미지 존재한다는 결과가 나왔습니다. 앞에서 이미 내려받은 `lates` 태그에 해당 레이어가 있기 때문입니다.

```bash 
docker ps -f id=ce7

docker ps -f name=nginx
```

> 서버에 도커 컨테이너가 많은 경우 위의 -f 필터옵션을 주어서 원하는 이미지나 컨테이너를 조회할 수 있습니다.

## 2. 컨테이너 내부 파일 변경하기

도커는 컨테이너 내부에서 컨테이너 외부의 파일을 사용할 수 있는 방법으로는 크게 4가지를 제공합니다.

- docker cp: docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로> 형식으로 호스트에 위치한 파일을 구동 중인 컨테이너 내부에 복사합니다. 주로 컨테이너에서 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해서 사용되거나 컨테이너에 저장돼 있는 설정 및 로그를 추출하는 용도로 사용됩니다.

- Dockerfile ADD: 이미지는 Dockerfile을 기반으로 만들어지는데, 이때 Dockerfile에 ADD라는 구문으로 컨테이너 내부로 복사할 파일을 지정하면 이미지를 빌드 할 때 지정한 파일이 이미지 내부로 복사됩니다. 이후 해당 이미지를 기반으로 구동한 컨테이너에서는 복사한 파일을 사용할 수 있습니다.

- 바운드 마운트: 호스트 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법입니다. 새로운 컨테이너를 구동할 때도 호스트와 연결할 파일이나 디렉터리 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있습니다. 주로 컨테이너가 바뀌어도 없어지면 안되는 `자료(DB, 첨부파일 등)`는 이 방법으로 보존이 가능합니다. 

- 볼륨: 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 도커가 관리하는 볼륨을 컨테이너와 연결합니다. 여기서 말하는 볼륨은 쿠버네티스에서 살펴본 볼륨 구조와 유사합니다. 따라서 도커가 관리하는 `NFS`와 같은 공유 디렉터리에 생성한다면 다른 호스트에도 도커가 관리하는 볼륨을 함께 사용께 수 있습니다.

### 2.1 바인드 마운트로 호스트와 컨테이너 연결

호스트와 컨테이너를 연결하려면 대상이 되는 컨테이너 내부의 디렉터리 구조를 먼저 알아야 합니다. 

nginx 컨테이너 구조를 살펴보면 처음 접속할 때 노출되는 페이지는 `/usr/share/nginx/html/index.html`입니다. 따라서 수정해야 하는 파일은 `index.html`이며, 이러한 경로 설정은 /etc/nginx/nginx.conf에 존재합니다.

이제 호스트와 컨테이너 내부를 연결하는 실습을 진행 해보겠습니다.



먼저, 컨테이너 내부에 연결할 /root/html/ 디렉터리를 호스트에 생성

```bash
mkdir -p /root/html
```

바인드 마운트 옵션을 주어서 컨테이너 기동 명령어 실

```bash
docker run -d -p 8080:80 -v /root/html:/usr/share/nginx/html -- restart always --name nginx-bind-mounts nginx
```

nginx가 정상적으로 접속되는지 `curl`로 확인해봤습니다.

```bash
curl localhost:8081
```

<html>
<head><title>403 Forbidden</title></head>
<body>
<center><h1>403 Forbidden</h1></center>
<hr><center>nginx/1.23.4</center>
</body>
</html>


이럴수가.. 403 에러를 보여주고 있습니다. 
그 이유는 바인드 마운트로 호스트와 컨테이너 내부를 연결했지만, 호스트에는 설정한 디렉터리에 파일이 없기 때문에 바인드 마운트 시 호스트 디렉터리를 기준으로 컨테이너 디렉터리에 엎어쳐집니다. 

다시 cp 명령어로 호스트 디렉터리와 컨테이너 디렉터리를 연결할 때 사용할 `index.html`을 /root/html/에 복사합니다.

```bash
cp ~/_Book_k8sinfra/ch4/4.2.3/index-BindMount.html /root/html/index.html
```

다시 브라우저에서 192.168.1.10:8081로 접속해 다음과 같이 index.html이 표시되는지 확인하였습니다.

![스크린샷 2023-04-23 오후 1 21 42](https://user-images.githubusercontent.com/22395934/233823216-db2bdd1b-cce6-497e-91f2-b21651e43a64.png)


### 2.1 볼륨으로 호스트와 컨테이너 연결


이제 도커가 관리하는 볼륨방식으로 컨테이너와 연결해보는 실습을 하였습니다.

볼륨은 도커가 직접 관리하며 컨테이너에 제공하는 호스트 공간입니다. 

```bash
docker volume create nginx-volume # nginx-volume 명을 가진 volume 생성
```

생성된 볼륨을 조회합니다. 볼륨에 적용된 드라이버 종류와 실제 호스트에 연결된 디렉터리, 볼륨 이름 등을 조회할 수 있습니다.

```bash
docker volume inspect nginx-volume
```

![image](https://user-images.githubusercontent.com/22395934/233823309-5161c659-5926-404c-acdb-51877fbc642b.png)

Mountpoint 행의 `/var/lib/docker/volumes/nginx-volume/_data` 디렉터리가 볼륨 디렉터리임을 확인할 수 있습니다. 

컨테이너에 연결할 볼륨을 호스트에 생성했으니 호스트와 컨테이너 디렉터리를 연결할 컨테이너를 구동합니다.

```bash
docker run -d -v nginx-volume:/usr/share/nginx/html -p 8082:80 --restart always --name nginx-volume nginx
```

볼륨 디렉터리의 내용을 다시 확읺합니다. 바인드 마운트와 다르게 볼륨은 빈 디렉터리를 덮어쓰지 않고 컨테이너 내부에 있는 `50x.html, idex.html` 파일을 보존하는 것을 확인할 수 있었습니다.

![image](https://user-images.githubusercontent.com/22395934/233823473-2406d5cf-7028-48ec-ae9f-5e69252b3fb1.png)

짜잔.. 브라우저에서 192.168.1.10:8082로 접속 후 리소스가 잘 나오는지 확인해봤습니다.

![스크린샷 2023-04-23 오후 1 22 58](https://user-images.githubusercontent.com/22395934/233823532-6d3554af-a7b4-4460-b425-5a30ab86598a.png)

핀트는 볼륨은 바인드 마운트와 달리 호스트 디렉터리를 컨테이너 디렉터리에 덮어쓰는 구조가 아니라 양쪽을 서로 동기화시키는 구조이기 때문에 비어 있는 볼륨을 연결하는 경우에는 컨테이너 디렉터리에 있는 파일이 보존됩니다. 

하지만 볼륨에 컨테이너 디렉터리와 동일한 파일이 존재한 상태로 연결하는 경우에는 덮어쓰기가 되니 이점에 유의해야 합니다.

> 실습에서 볼륨은 /var/lib/docker/volumes/ 디렉터리 안에 생성됬습니다. 리눅스의 시스템 디렉터리 정의에 따르면 var 디렉터리는 시스템이 사용하는 파일 중 로그, 캐시, 상태 정보등을 저장합니다. 만약 도커의 볼륨에서 사용하는 데이터가 늘어날 수록 시스템의 다른 기능이 사용해야 하는 용량까지 차지하는 문제가 발생할 수 있습니다. 이 경우에는 별도로 볼륨을 다른 경로로 분리해야 합니다. docker-ce 17.05 버전부터는 도커의 데몬 설정에서 볼륨이 저장되는 경로를 지정하는 --data-root 옵션이나 호스트 경로와 컨테이너 경로를 명확하게 연결하는 --mount 옵션을 제공하고 있습니다.

## 3. 도커 컨테이너 이미지 만들기

컨테이너 이미지를 만드는 방법은 다음과 같이 4가지 입니다.

- 기본적인 빌드
- 용량 줄이기
- 컨테이너 내부 빌드
- 멀티 스테이지

### 3.1 기본 방법으로 빌드

먼저, 가장 간단한 방법부터 실습해보겠습니다.
스프링 부트를 이용해 만든 자바 소스 코드로 이미지를 빌드하겠습니다. 

자바 소스 빌드 -> 도커 파일 작성 -> 도커 파일 빌드 -> 빌드완료

일단 컨테이너 이미지를 빌드하기 위해 `Dockerfile`이 필요합니다. 

소스코드가 자바로 작성돼 있으므로 실행 가능한 Jar로 만들려면 JDK가 설치해야 하는데, 1.8 버전으로 설치하면 됩니다.

```bash
yum install java-1.8.0-openjdk-devel -y
```

자바를 빌드할 때는 Gradle, Maven 등이 대표적이지만 여기서는 Maven을 사용했습니다.

```bash
chmod 700 mvnw

./mvnw clean package
```
![image](https://user-images.githubusercontent.com/22395934/233833492-5c69307a-c003-42d4-895f-b92afd83835b.png)

openjdk 설치 및 jar 파일 패키징까지 완료되었으면 이제 도커 파일을 이용하여 컨테이너 이미지를 빌드합니다.

```bash
docker build -t basic-img .
```

```docker 
FROM openjdk:8 # <이미지 이름>:[태그]
LABEL description="Echo IP Java Development"
EXPOSE 60431
COPY ./target/app-in-host.jar /opt/app-in-image.jar
WORKDIR /opt # 이미지의 현재 작업 위치 /opt로 변경
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]
```

도커 파일을 살펴보면 openjdk 이미지를 가져와서 내부에서 컨테이너 이미지를 빌드합니다. 간단하게 말해서 누군가가 만들어 놓은 이미지에 필요한 부분을 추가한 것입니다. 여기서는 `openjdk`를 기초 이미지로 사용합니다. 

두 번째줄의 LABEL은 `<레이블 이름>=<값>` 형식으로 이미지에 부가적인 설명을 위한 레이블을 추가할 때 사용합니다. 

`ENTRYPOINT ["명령어", "옵션"... "옵션"]`의 형식입니다. 컨테이너 구동 시 ENTRYPOINT 뒤에 나오는 대괄호([]) 안에 든 명령을 실행합니다. 

이제 이미지가 잘 빌드되었는지 아래와 같이 명령어로 확인해봅니다.

```bash
docker images basic-img
```

태그가 `latest`로 생성된 것을 확인할 수 있었습니다. 

docker build 태그 옵션을 추가해 1.0, 2.0 태그의 이미지도 생성해 봤습니다. 캐시가 사용되어 매우 빠르게 빌드됩니다.

![스크린샷 2023-04-23 오후 5 26 22](https://user-images.githubusercontent.com/22395934/233834066-e9b0bd90-f049-4533-8fba-d7b3ef7cd2fa.png)

생성된 이미지를 다시 확인해보면 1.0, 2.0 태그를 가진 이미지가 모두 ID가 `fd708ef6d1fb`와 용량이 모두 같은 것을 볼 수 있었습니다. 즉, 이미지들은 태그 정보만 다를 뿐 모두 같은 이미지이며, 한 공간을 사용합니다. 리눅스의 소프트 링크와 비슷합니다.

![스크린샷 2023-04-23 오후 5 38 36](https://user-images.githubusercontent.com/22395934/233834106-ca583459-7e14-4a48-ac15-53a80e38adcb.png)

3.0 태그는 도커 파일에서 LABEL 정보만 바꿔서 다시 빌드한 버전입니다. 

```bash
sed -i 's/Application/Development/` Dockerfile
```

3.0은 다른 태그들과 다르게 ID가 다르다는 것을 알 수 있었습니다. 


이제 생성된 도커 이미지를 컨테이너로 띄워봤습니다.

![image](https://user-images.githubusercontent.com/22395934/233834384-4c8c2fab-9ed1-45e9-8ae0-fce7636b226e.png)

```bash
curl 127.0.0.1:60431

# 실행결과
src: 172.17.0.1 / dest: 127.0.0.1
```

정상적으로 응답이 오는것을 확인했습니다.

이제 다시 컨테이너를 삭제해보겠습니다.

```docker
docker stop $(docker ps -f ancestor=nginx) # nginx 이미지 기반의 모든 컨테이너 중지

docker rm $(docker ps -aq -f ancestor=nginx) # nginx 이미지 기반의 중지된 컨테이너들 전부 삭제

docker rmi $(docker images -q basic-img)
```

> 참고문헌: 쿠버네티스 도커를 활용한 인프라 환경 
